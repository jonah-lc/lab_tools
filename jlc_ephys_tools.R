##### Script to plot data from minION runs ####
##### Expects data in .csv format that has been manually outputted from traceviewer
##### right click & save all 4x muxes, and channel splitting occurs within the script.
##### rawimport to be finalised later
##### these tools are provided as WIPS

library(rhdf5)
library(ggplot2)
library(cowplot)
library(grid)
library(gridExtra) 
library(ggpubr)
library(scales)
library(signal) 

source("/media/jonah/Lickitung/SYNC/4-SCRIPTS/R/jlc_lab_tools.R")

modalAvg <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

chanStrip = function(cmux_list){
  ## feed in list of channel-mux combinations, will strip mux from each entry in list
  # cmux_list   (list, int)     list of channel muxes eg c(1023, 5032, 132)
  out  = lapply(cmux_list, function(x) x= substr(x,1,nchar(x)-1))
}

muxr = function(folder_path, in_file, channel){
  ## To be used inside dataGrab. Will read in individual channels and seperate muxes
  # Variables
  # folder_path     (str)     path with per channel csvs in, extracted from traceviewer
  # in_file         (str)     single .csv file located in folder_path, canoncially named channelnumber.csv eg 112.cs
  # channel         (int)     single channel number     
  inp = read.csv(paste0(folder_path,in_file))
  inp = read.delim(paste0(folder_path,in_file))
  names(inp) = c()
  inp = data.frame(time=inp[,3], current=inp[,4], voltage=inp[,6])
  nline = nrow(inp)/4
  muxes = c(rep(1,nline),rep(2,nline),rep(3,nline),rep(4,nline))
  inp$mux =  muxes
  inp$channel = as.numeric(gsub("[^0-9]", "", in_file))
  inp$number = channel
  return(inp)
}

dataGrab = function(folder_path, exp_id){
  ## Will input csv data extracted from traceviewer.
  # Variables
  # folder_path     (str)     path with per channel csvs in, extracted from traceviewer
  # exp_id          (str)     identifier for this particular experiment
  files = list.files(pattern = ".csv", path=folder_path)
  df = data.frame()
  for (i in seq(1,length(files))){
    infile = files[[i]]
    tmp = muxr(folder_path,infile,i)
    df = rbind(df,tmp)
    rm(tmp)
  }
  ## prepare comb (i.e. channel-mux) column for later subsetting
  df$comb = as.numeric(as.character(paste0(df$channel,df$mux)))
  df$exp_id = exp_id
  return(df)
}

getInsertion = function(df, insertion_list, insertion_name){
  ## Calculate IV plot
  ## give list of channels with similar IVs
  ## subset df into just those channels & muxes (eg c1 m2 = 12)
  ## for each channel, calculate an average current value and sd for each voltage step
  ## then average across the channels, and determine SEM
  ## SEM is calculated by taking the standard deviation and dividing it by the square root of the sample size.
  # Input Variables
  # df              (df)          dataframe of runs generated by muxr function
  # insertion_list  (list, ints)  list of channel-mux values to extract, eg channel 100, mux 3 would be 1003
  # insertion_name  (str)         identifier for this "type" on insertion, can be anything      
  tdf = subset(df, df$comb %in% insertion_list)
  plotdf = data.frame()
  for (v in unique(tdf$voltage)){
    ## per volatage dataframe
    tmp = subset(tdf, tdf$voltage==v)
    cdf = data.frame()
    ## loop over each channel-mux combo
    for (c in unique(tmp$comb)){
      ## df with voltage, channel-mux (comb), and time averaged current & SD for this voltage step
      ## need to remove initial spike before averaging!
      tmp2 = subset(tmp, tmp$comb==c)
      tmp1 = data.frame(voltage=tmp2$voltage[1], per_chan_current=mean(tmp2$current),
                        per_chan_sd=sd(tmp2$current),comb=tmp2$comb[1])
      cdf = rbind(cdf, tmp1)
    }
    ## Calculate average current value for this voltage step for this insertion type for averaged IV plot
    cdf$current = mean(cdf$per_chan_current)
    ## Calculate SEM for IV plot
    cdf$current_sem = sd(cdf$per_chan_current)/sqrt(nrow(cdf))
    plotdf = rbind(plotdf, cdf)
  }
  ## add identifier for this insertion type
  plotdf$id = insertion_name
  return(plotdf)
}


ivPlot = function(input_df, trace_colours, trace_label, lims=c(-200,200)){
  ## plots a single channel-mux combo for example traces for publication. Will reset x axis to start from 0 seconds
  # Variables
  # input_df      (df)          dataframe, in format outputted by getInsertion
  # lims          (list, ints)  list of limits for both axis (voltage) eg c(200,-200)
  # trace_colours (list, str)   list of colours to plot traces in, can be hex code to plain text eg "Black", needs one per "id" var in df
  # trace_label   (list, str)   As above, but for labels, can be any string
  ## fix labels
  input_df$id = factor(input_df$id, levels= trace_label)
  
  iv = ggplot(input_df, aes(y=current, x=voltage, ymin=(current-current_sem), 
                            ymax = (current+current_sem), colour=id))+
    geom_point()+
    geom_errorbar(width = 8, alpha=0.2)+
    geom_vline(xintercept = 0,) + geom_hline(yintercept=0)+
    theme_bw(base_size = txt_size)+
    scale_colour_manual(values = trace_colours, 
                        name = "")+
    xlim(lims)+ylim(lims)+
    xlab("Voltage / mV") + ylab("Current / pA\n")+
    My_Theme
  return(iv)
  
}

hisPlot = function(input_df, trace_colours, bins, his_voltage){
  ## plots a single channel-mux combo for example traces for publication. Will reset x axis to start from 0 seconds
  # Variables
  # input_df      (df)          dataframe, in format outputted by getInsertion
  # trace_colours (list, str)   list of colours to plot traces in, can be hex code to plain text eg "Black", needs one per "id" var in df
  # bins          (int)         number of bins to plot histogram with
  # his_voltage   (int)         voltage to plot histogram at, suggest 25
  input_df = subset(input_df, input_df$voltage == his_voltage)
  input_df$id
  ## generate conductance measurements
  input_df$conductance = input_df$per_chan_current/his_voltage
  ## subset dataframe to only show +ve conductances at the desired voltage
  #input_df = subset(input_df, input_df$voltage==his_voltage & input_df$conductance > 0.01)
  his = ggplot(input_df,
               aes(x=conductance, fill=id))+
    geom_histogram(bins=bins)+
    theme_bw(base_size = txt_size)+
    scale_fill_manual(values = trace_colours, name = "")+
    xlab("Conductance / nS") + ylab("Counts")+
    scale_y_continuous( breaks=pretty_breaks(n=6))+
    scale_x_continuous( breaks=pretty_breaks(n=4))+
    My_Theme
  return(his)
}

exPlotterRaw = function(path, example_comb_list, lims=c(-200,200), 
                        trace_colour_list, volts, downsample=0.1,
                        line_size=0.05, offset_fix="n") {
  ## plots a single channel-mux combo for example traces for publication. Will reset x axis to start from 0 seconds
  # Variables
  # path                  (str)         path of raw data file to read in
  # example_comb _list    (list,int)    list of single channel-mux (aka comb) combinations to plot
  # lims                  (list, ints)  list of limits for y axis (voltage) eg c(200,-200)
  # trace_colour_list     (list,str)    List of colours to plot traces in, can be hex code to plain text eg "Black"
  # volts                 (y/n)         yes/no input, should voltage be shown on plot
  # line_size             (int)         size to plot lines on graphs  
  
  ## Read in Raw Data
  sdf2 = do.call(rbind, lapply(example_comb_list, rawImport, path=path, downsample=downsample, hq="yes", offset_fix=offset_fix))
  ## ensure order is correct
  sdf2$comb = factor(sdf2$cm, levels = example_comb_list)
  
  ## plot with or without voltages
  if (volts =="yes" | volts == "y"){
    out = ggplot(sdf2, aes(colour=as.character(comb)))+
      geom_line(aes(x=time,y=current),size= line_size)+
      geom_line(aes(x=time, y=voltage), colour="black", size= 0.5, alpha = 0.85)+
      scale_y_continuous(limits = lims, breaks=pretty_breaks(n=6),
                         sec.axis = sec_axis(~ ., name = "Voltage / mV"))+
      scale_x_continuous( breaks=pretty_breaks(n=6))+
      scale_colour_manual(values=trace_colour_list, name="")+
      xlab("Time / s") + ylab("Current / pA\n")+
      theme_bw(base_size = txt_size)+
      facet_grid(comb~.)+
      My_Theme+
      theme(
        strip.background = element_blank(),
        strip.text.x = element_blank(),
        strip.text.y = element_blank(),
        legend.position = "none"
      )
  } else {
    out = ggplot(sdf2, aes(colour=as.character(comb)))+
      geom_line(aes(x=time,y=current),size=0.05)+
      #geom_line(aes(x=sdf$time,y=sdf$voltage), colour="grey", size= 0.5, alpha = 0.5)+
      scale_y_continuous(limits = lims, breaks=pretty_breaks(n=6),
                         sec.axis = sec_axis(~ ., name = "Voltage / mV"))+
      scale_x_continuous( breaks=pretty_breaks(n=6), limits=c(0,500))+
      scale_colour_manual(values=trace_colour_list, name="")+
      xlab("Time / s") + ylab("Current / pA\n")+
      theme_bw(base_size = txt_size)+
      facet_grid(comb~.)+
      My_Theme+
      theme(
        strip.background = element_blank(),
        strip.text.x = element_blank(),
        strip.text.y = element_blank(),
        legend.position = "none"
      )
  }
  return(out)
}

transLocationDfPrep = function(df1, df2, trans_labs, trans_voltage=100, time_steps=c(1,30), all_chans, raw="y", offset_fix ="y" ){
  ## Prepares databases from 2 IV curves with & without analytes for plotting & analysis
  # Variables
  # df1/2      (df)            dataframe output from dataGrab. Should be subset with list of active channels (eg c(inv, high, reg))
  # trans_labs    (list, str) list of labels for the two conditions
  # trans_voltage (int)       voltage step from the IV curve to use for translocation analysis
  # time_steps    (list, int) list of start and end times. For a standard IV with 30 s step, pass in c(0,30)
  # all_chans     (y/n)       if inputted yes or y, only with pores channels present in both experiments will be used
  # raw           (y/n)       select yes if extracted raw data, no if extracted from traceviewer 
  # offset_fix  (y/n)         if yes will attempt to correct any offsets
  
  ## create data frames of two experiments & cut to single voltage
  if (raw == "y" | raw =="yes"){
    df1 = data.frame(time=df1$time, current=df1$per_chan_current, voltage=df1$voltage,
                     comb=df1$cm, exp_id=df1$id)
    df2 = data.frame(time=df2$time, current=df2$per_chan_current, voltage=df2$voltage,
                     comb=df2$cm, exp_id=df2$id)
  }
  
  ## for each df get list of current at v=0
  ## make avg current for each cmux at v=0
  if (offset_fix == "y" | offset_fix == "yes"){
    offd1 = subset(df1, df1$voltage==0)
    offd2 = subset(df2, df2$voltage==0)
    offset_1 = aggregate(current ~ comb, offd1, modalAvg)
    offset_2 = aggregate(current ~ comb, offd2, modalAvg)
  }
  pre_ana_full = subset(df1, df1$voltage==trans_voltage)
  pre_ana_full$exp = trans_labs[1]
  post_ana_full = subset(df2, df2$voltage==trans_voltage)
  post_ana_full$exp = trans_labs[2]
  
  if (all_chans == "yes" | all_chans == "y"){
    ## determining channels present in both experiments
    active = subset(pre_ana_full, pre_ana_full$comb %in% post_ana_full$comb)
    active = unique(active$comb)
    cdf = rbind(subset(pre_ana_full, pre_ana_full$comb %in% active),
                subset(post_ana_full, post_ana_full$comb %in% active))
    ## how many channels is that?
    print(c(length(active),"active channel-muxes present in both experiments"))
  } else {
    cdf = rbind(pre_ana_full, post_ana_full)
    print(c(length(unique(pre_ana_full$comb)),"active channel-muxes present in",trans_labs[1]))
    print(c(length(unique(post_ana_full$comb)),"active channel-muxes present in",trans_labs[2]))
  }
  out = data.frame()
  for (i in unique(cdf$comb)){
    #unique(cdf$comb)
    tmp = subset(cdf, cdf$comb==i)
    tmp$time = tmp$time - tmp$time[1]
    ## offset fix
    if (offset_fix == "y" | offset_fix == "yes"){
      odt1 = subset(tmp, tmp$exp==trans_labs[1])
      odt2 = subset(tmp, tmp$exp==trans_labs[2])
      offset_val1 = offset_1$current[offset_1$comb==i]
      offset_val2 = offset_2$current[offset_2$comb==i]
      odt1$current = odt1$current+offset_val1
      odt2$current = odt2$current+offset_val2
      tmp=rbind(odt1, odt2)
    }
    ## cut to desired time step plus remove spikes at start and end
    tmp = subset(tmp, tmp$time > (time_steps[1]+2) & tmp$time < (time_steps[2]-2))
    
    
    ## remove any spikes prior to normalisation
    ################################################################################################################## this will need to be reversed for reverse polarity sequencing
    tmp = subset(tmp, tmp$current < (modalAvg(tmp$current)*1.25))
    ## need to change above to not a subset, just delete any rows that are x amount higher or lower then avg
    
    ## normalise
    tmp$norm = norm(tmp$current)
    #tmp$norm=tmp$current
    #transPlot(tmp, "y", "y")
    out = rbind(out, tmp)
    rm(tmp)
  }
  return(out)
}

transPlot = function(input_df, facet="y", fac_labs="y", norm="y"){
  ## Prepares plots of curent/time for final graps
  # Variables
  ## input_df       (df)      data frame in the format outputted by transLocationDfPrep
  ## facet          (y/n)     if yes, will facet plots for different experiment types
  ## fac_labs       (y/n)     if yes, will add labels to facet plots
  ## norm           (y/n)     plot normalised (y) or un-normalised current
  if (norm == "y" | norm == "yes"){
    pout = ggplot(input_df)+
      geom_line(aes(x=time,y=norm))+
      xlab("Time / s") + ylab("Current / pA\n")+
      theme_bw(base_size = txt_size)+
      My_Theme+
      theme(
        strip.background = element_blank(),
        strip.text.x = element_blank(),
        strip.text.y = element_blank(),
        legend.position = "none"
      )
  } else {
    pout = ggplot(input_df)+
      geom_line(aes(x=time,y=current))+
      xlab("Time / s") + ylab("Current / pA\n")+
      theme_bw(base_size = txt_size)+
      My_Theme+
      theme(
        strip.background = element_blank(),
        strip.text.x = element_blank(),
        strip.text.y = element_blank(),
        legend.position = "none"
      )
  }
  if (facet == "y" | facet == "yes"){
    pout = pout + facet_grid(exp~comb)
  }
  if (fac_labs == "y" | fac_labs == "yes"){
    pout = pout+My_Theme
  }
  return(pout)
}

eventHisr = function(input_df, facet, fac_labs, bin_size=50){
  ## Creates histogram of event current vs event frequency (not dwell time)
  # Variables
  ## input_df       (df)      data frame in the format outputted by transLocationDfPrep
  ## facet          (y/n)     if yes, will facet plots for different experiment types
  ## fac_labs       (y/n)     if yes, will add labels to facet plots
  ## bin_size       (int)     number of bins to plot histogram with
  out = ggplot(input_df, aes(x=norm))+
    geom_histogram(bins=bin_size)+
    theme_bw(base_size = txt_size)+
    #scale_fill_manual(values = cols)+
    ylab("Frequency") + xlab("Normalised Current / pA\n")+
    scale_x_continuous(breaks=pretty_breaks(n=5))+
    scale_y_continuous(trans='log10',
                       breaks = trans_breaks('log10', function(x) 10^x),
                       labels = trans_format('log10', math_format(10^.x)))+
    #scale_x_continuous( breaks=pretty_breaks(n=6))+
    My_Theme+coord_flip()+
    theme(
      strip.background = element_blank(),
      strip.text.x = element_blank(),
      strip.text.y = element_blank(),
      legend.position = "none"
    )
  if (facet == "y" | facet == "yes"){
    out = out + facet_grid(exp~.)
  }
  if (fac_labs == "y" | fac_labs == "yes"){
    out = out+My_Theme
  }
  return(out)
}


sortIntoArray = function(row, open_pore_current, polarity="+"){
  ### requires Global vars;
  # Event       (boo)           Event status
  # Counter     (int)           counter for events
  # ddf         (df)            dataframe, needs to be initlaised outside this environment for reaosns I don' really understand
  ### Local vars
  # row         (list)          list of ints, rows from input_df
  # open_pore   (int)           value below which counts as event (will need to be changed for +ve / -ve seq)
  ##### polarity    (str)           if "+", assumes volatage is +ve, else assumes negative.
  
  ## put row into df to allow atomic vectors for readability
  row = data.frame(comb = row[1] ,time=row[2],current=row[3],norm=row[4], exp=row[5])
  ## generate output dataframe
  ddf = data.frame()
  ## polairty + means events should spike down from open pore current 
  if (polarity == "+") {
    if (row$norm <= open_pore_current) {    ## if current drops below open_pore_current, we now are in an event
      Event <<- TRUE
      ## if we are in an Event, we add new event information to outdf
      outputrow = data.frame(time=as.numeric(row$time), 
                             event_count=Counter, 
                             norm_event_current=as.numeric(row$norm), 
                             event_current = as.numeric(row$current),
                             exp=row$exp)
      ## append to df
      ddf <- (rbind( ddf, outputrow))
      return(ddf)
    } else {  ## (if row$norm is equal or above open pore, so we are not in an event
      if (Event == TRUE) {
        ## if current is above open_pore and we are in an event, end event and increment counter
        ## and set previous current back to open pore
        Event <<- FALSE
        Counter <<- (Counter + 1)
      }
      ## if current is above open_pore and we are not in event, we need do nothing
    }
  } else { print("not coded for translocations that spike form zero to one yet, theoretically easy but not done yet...")}
  return()
}





eventDetector = function(input_df, open_pore_current=0.8, polarity="+"){
  ## Detects events by setting Event status & event counter into global environment
  ## then applys sortIntoArray across each row of the dataframe.
  ## Events are counted as any time the current surpasses the open_pore_current
  # Variables
  # input_df                (df)      data frame in the format outputted by transLocationDfPrep
  # open_pore_current       (int)     value below which counts as event (will need to be changed for +ve / -ve seq)
  # polarity                (str)     if "+", assumes volatage is +ve, else assumes negative.
  ### Set Init Vars (using <<- to set to global env!)
  Event <<- FALSE
  Counter <<- 0
  # subset input dataframe
  indf = input_df
  indf = data.frame(comb = indf$comb, time=indf$time, current=indf$current, norm=indf$norm, exp=indf$exp)
  ## initliase ddf
  #ddf <<- data.frame()
  ## run sortIntoArray function to populate ddf
  ddf = do.call(rbind, apply(indf,1, sortIntoArray, open_pore_current = open_pore_current, polarity=polarity))
  ## create data frame and populate with events, average and SD of currents and event lengthfrom ddf
  out = data.frame()
  for (i in seq(1,max(ddf$event_count))){
    temp = subset(ddf, ddf$event_count==i)
    out = rbind(out, data.frame(
      #duration=(max(temp$time)-min(temp$time)),
      duration = mean(temp$time),
      event_count = unique(temp$event_count),
      avg_norm_current = modalAvg(temp$norm_event_current),
      sd_norm_current = sd(temp$norm_event_current),
      avg_current = modalAvg(temp$event_current),
      sd_current = sd(temp$event_current),
      exp = temp$exp))
    
    out[is.na(out)] <- 0
    ## above should probably be a call to aggregate insteads
    ## this data frame call is apparently fucking essential to any of this stupid code working
    out = data.frame(unique(out))
  }
  return(out)
}

dwellPlotter = function(dwell_df, facet="y", fac_labs="y"){
  ## Prepares plots dwell time vs normalised block level
  # Variables
  ## dwell_df       (df)      data frame in the format outputted by eventDecector
  ## facet          (y/n)     if yes, will facet plots for different experiment types
  ## fac_labs       (y/n)     if yes, will add labels to facet plots
  out = ggplot(dwell_df, aes(x=duration, y=avg_norm_current,
                             ymin=avg_norm_current-sd_norm_current, 
                             ymax = avg_norm_current+sd_norm_current))+
    geom_point()+
    theme_bw(base_size = txt_size)+
    ylim(c(0,1))+
    scale_x_continuous(trans='log10',
                       breaks = trans_breaks('log10', function(x) 10^x),
                       labels = trans_format('log10', math_format(10^.x)))+
    xlab("Dwell Time / s")+ylab("Normalised Block Level / %\n")+
    My_Theme+
    theme(
      strip.background = element_blank(),
      strip.text.x = element_blank(),
      strip.text.y = element_blank(),
      legend.position = "none"
    )
  if (facet == "y" | facet == "yes"){
    out = out + facet_grid(exp~.)
  }
  if (fac_labs == "y" | fac_labs == "yes"){
    out = out+My_Theme
  }
  return(out)
}

dwellArranger = function(input_df, trans_labs, open_pore_current=0.8, his_bins=15, p_margin=10, example_combs, polarity="+"){
  ## Arranges plots of translocation events
  # Variables
  # input_df                (df)          Input df prepared by TransLocationDfPrep (raw or otherwise)
  # trans_labs              (list, str)   list of labels for the two conditions
  # open_pore_current       (int)         value below which counts as event (will need to be changed for +ve / -ve seq)
  # his_bins                (int)         bins to plot histogram with
  # p_margin                (int)         margin between plots
  # examples_combs          (list, ints)  list of example channel-mux combs to plot (eg c(1342, 6442))
  # polarity                (str)         if "+", assumes volatage is +ve, else assumes negative.
  
  ## Generate event dataframe
  dwells = eventDetector(input_df, open_pore_current, polarity = polarity)
  dwells$exp_id = factor(dwells$exp, levels = trans_labs)
  dwells$exp = factor(dwells$exp, levels = trans_labs)
  input_df$exp_id = input_df$exp ## fixing bad coding
  ## Generate plots
  tp = transPlot(subset(input_df, input_df$comb %in% example_combs), "y", "n")
  ev = eventHisr(input_df, "y", "n", his_bins)
  dp = dwellPlotter(dwells, "y", "n")
  ## arrange
  out = plot_grid(tp+theme(panel.spacing = unit(1, "lines"),
                           plot.margin=margin(c(p_margin,p_margin,p_margin,p_margin))),
                  ev+theme(panel.spacing = unit(1, "lines"),
                           plot.margin=margin(c(p_margin,p_margin,p_margin,p_margin))),
                  dp+theme(panel.spacing = unit(1, "lines"),
                           plot.margin=margin(c(p_margin,p_margin,p_margin,p_margin))),
                  nrow=1, rel_widths = c(0.7,0.3,0.3), labels = "auto", label_size = txt_size*1.2,
                  label_fontface = "plain")
  
  return(out)
}